# -*- coding: utf-8 -*-
"""ft_reg.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QqdkOy3rsG8RJQKH2bZ_6fFvtQKcfLtK
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mlxtend.preprocessing import minmax_scaling

df = pd.read_csv("/content/data.csv")
miles =  df["km"].to_numpy()
price =  df["price"].to_numpy()
miles = miles.reshape(miles.shape[0], 1)
price = price.reshape(price.shape[0], 1)
plt.scatter(miles,price) 
scaled_price = minmax_scaling(price, columns=[0])
scaled_miles = minmax_scaling(miles, columns=[0])
plt.scatter(scaled_price, scaled_miles)

scaled_price = minmax_scaling(price, columns=[0])
scaled_miles = minmax_scaling(miles, columns=[0])
plt.scatter(scaled_price, scaled_miles)

theta0 = 0
theta1 = 0
theta = np.array([theta1, theta0]).reshape(2, 1)
X = np.hstack((scaled_miles, np.ones(scaled_miles.shape)))

def model(X, theta):
    return X.dot(theta)

def cost_function(X, y, theta):
    m = len(y)
    return 1/(2*m) * np.sum((model(X, theta) - y)**2)

def grad(X, y, theta, learning_rate, n_iterations):
  cost_history = np.zeros(n_iterations)
  m = len(y)
  for i in range(n_iterations):
    theta = theta - learning_rate * 1/m * X.T.dot(model(X, theta) - scaled_price)
    # mise a jour du parametre theta (formule du gradient descent)
    cost_history[i] = cost_function(X, y, theta) # on enregistre la valeur du Cout au tour i dans cost_history[i] 
  return theta, cost_history
    

  # return 1/m * X.T.dot(X.dot(theta) - scaled_price)

n_iterations = 1000000
learning_rate = 0.001


theta_final, cost_history = grad(X, scaled_price, theta, learning_rate, n_iterations)
print(theta_final, cost_history)

predictions = model(X, theta_final)

plt.plot(range(n_iterations), cost_history)

def coef_determination(y, pred):
    u = ((y - pred)**2).sum()
    v = ((y - y.mean())**2).sum()
    return 1 - u/v

coef_determination(scaled_price, predictions)

x_ = np.linspace(min(scaled_miles), max(scaled_miles), 100)
y_ = theta_final[0] * x_ + theta_final[1]
print(theta)
plt.plot(x_, y_, c='g')
plt.scatter(scaled_miles, scaled_price, c='r')

